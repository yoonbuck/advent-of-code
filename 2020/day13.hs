module Day13 where

import           Data.List.Split (splitOn)
import           Data.List (minimumBy)
import           Data.Function (on)
import           Data.Bifunctor (second)

type Input = (Int, [Int])

parse :: String -> Input
parse = (\[a, b] -> (read a, map read $ filter (/= "x") $ splitOn "," b))
  . lines

solveA :: Input -> Int
solveA (time, busses) = uncurry (*)
  $ minimumBy (compare `on` fst)
  $ map (\bus -> (bus - (time `rem` bus), bus)) busses

solveB :: String -> Integer
solveB = head
  . foldr (\p (a:b:_) -> filter p [a, b ..]) [1 ..]
  . map ((\(a, b) n -> n `rem` b == ((-a) `mod` b)) . second read)
  . filter ((/= "x") . snd)
  . zip [0 ..]
  . splitOn ","
  . head
  . tail
  . lines

{-

  How does solveB work?

  First, the input is parsed and converted to a list of predicates
  (:: Integer -> Bool) which the correct answer must satisfy, e.g., 

    [ \n -> n `rem` 17 == 16
    , \n -> n `rem` 37 == 36
    , \n -> n `rem` 449 == 448
    , \n -> n `rem` 23 == 22
    , \n -> n `rem` 13 == 12
    , \n -> n `rem` 19 == 18
    , \n -> n `rem` 607 == 606
    , \n -> n `rem` 41 == 40
    , \n -> n `rem` 29 == 28
    ]

  (This happens from map onwards.)
  Then the naive approach would be to find the solution like so:
    head . (\predicates -> filter (all predicates) [1..])

  This is what we want, but the correct answer (725169163285238) is large and
  can't be found by checking every integer starting at 1.
  Instead of trying all numbers we can go one predicate at a time and seive
  [1..] down to an appropriate list of candidates at each point.

  So first, we essentially do
    filter (\n -> n `rem` 29 == 28) [1..]
  This gives us
    [28, 57, 86, 115, 144, 173, 202, 231, 260, 289, ...]
  Again, because this is generated by a filter on [1..], it would be inefficient
  to continue to filter this as is.

  Instead, we can use the first two elements to get the same list efficiently
  using the range/step syntax for algebraic sequences (which this is):
    filter (\n -> n `rem` 41 == 40) [28,57..]
  This gives:
    [1188, 2377, 3566, 4755, 5944, 7133, 8322, 9511, 10700, 11889, ...]

  This is repeated until we have filtered using all of the predicates,
  and then we have a list of integers which satisfy all the requirements:
    [725169163285238, 1883125867272061, 3041082571258884, 4199039275245707, ...]

  This all happens in one delightful line:
    foldr (\p (a:b:_) -> filter p [a, b ..]) [1 ..]

  This is a fold over our predicates, starting with [1..] :: [Integer]
    where we take a predicate
      p :: Integer -> Bool
    and the previous list of candidates
      [a, b, ... (rest of list ignored, and not calculated)]
        => a, b :: Integer
    and return
      filter p [a,b,..] :: [Integer]
    which is the new list of candidates.

  Finally, we want the smallest valid solution, so head grabs the first element.

  hlint wants me to combine the map and fold into
    foldr ( (\p (a:b:_) -> filter p [a, b ..])
          . (\(a, b) n -> n `rem` b == ((-a) `mod` b))
          . second read
          ) [1 ..]
  But I find this quite a bit less clear :)

-}
main :: IO ()
main = do
  input <- getContents
  putStrLn $ "Part A: " ++ (show . solveA . parse) input
  putStrLn $ "Part B: " ++ (show . solveB) input
